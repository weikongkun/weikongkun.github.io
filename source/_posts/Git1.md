---
title: Git分支
---

# Git分支 #

## 1、分支简介 ##
> 在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，
> 
> 为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：
> 
    git add 
    git commit -m "dfas"

Git的默认分支名字为master分支，他和其他分支完全没有区别，之所以每一个仓库都有一个master分支，是因为`git init`命令默认创建它。
#### （1）分支创建 ####
    git branch testing
这会在当前所在的提交对象上创建一个指针。
Git当前有个HEAD的特殊指针,指向当前所在的本地分支，`git branch`命令仅仅创建了一个分支，并不会自动切换到新分支去。

可以用`git log`命令查看各个分支当前所指的对象，提供这一参数的是`--decorate`
#### （2）分支切换 ####
    git checkout testing
这样HEAD就指向testing分支了

**分支切换会改变你工作目录中的文件
在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。**

#### （3）项目分叉历史 ####
    git log --oneline --decorate --graph --all
#### （4）分支的新建和合并 ####
想要新建一个分支并同时切换到那个分支上，可以运行一个带有`-b`参数的`git checkout`命令：

    git checkout -b iss53
    switch to a new branch "iss53"

上述两条命令的简写

    git branch iss53
    git checkout iss53
#### （5）创建一个新分支指针 ####
提交iss53下的所有修改，切换带master分支。

    git checkout master
    switch to branch 'master'

将修改部署到直接上游的master分支，当master分支是要合并对象的上游，只需将指针右移，移动到合并对象处：

    git checkout master
    git merge hotfix

#### （6）删除分支 ####
    git branch -d hotfix

切回到正在的工作继续工作：

    git check iss53
    switch to branch "iss53"

#### （7）分支的合并 ####
    git check master
    Switch to branch 'master'
    git merge iss53

master不是iss53的直接祖先，这样不得不做一些额外的工作，Git会使用两个分支的末端所指的快照以及这两个分支的工作祖先，做一个简单的三方合并。

既然你的修改已经合并进来了，你已经不再需要 iss53 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。
#### （8）遇到冲突时的分支合并 ####


#### （9）分支管理 ####
`git branch`不仅可以创建与删除分支，如果不加任何参数运行他，会得到当前所有分支的一个列表。带有`*`号的是当前所在的分支。如果要查看每一分支的最后一次提交，使用`git branch -v`命令。  
`--merged`与`--no-merged`这两个选项以过滤这个列表中的已经合并和尚未合并到当前分支的分支。

用`git branch -d`删除还未合并的工作会失败，可以用`-D`强制删除。
## 2、分支工作流 ##
#### （1）长期分支 ####
> 因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。
> 
> 许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。

#### （2）特性分支 ####

> 你已经在上一节中你创建的 iss53 和 hotfix 特性分支中看到过这种用法。 你在上一节用到的特性分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度



## 3、远程分支 ##

> 远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote (remote) 来显式地获得远程引用的完整列表，或者通过 git remote show (remote) 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。



> 远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。



> 它们以 `(remote)/(branch)` 形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 `origin/master` 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支；但是在服务器上的分支会指向 origin/iss53 的提交。



> 这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。

> 如果你在本地的 master 分支做了一些工作，然而在同一时间，其他人推送提交到 git.ourcompany.com 并更新了它的 master 分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin 服务器连接，你的 origin/master 指针就不会移动。
> 如果要同步你的工作，运行 `git fetch origin` 命令。 这个命令查找 “origin” 是哪一个服务器，从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针指向新的、更新后的位置。



> 当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。
> 如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 `git push (remote) (branch）`。



> **你也可以运行 git push origin serverfix:serverfix，它会做同样的事 - 相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。**
> 下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用。
> 要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支 - 只有一个不可以修改的 origin/serverfix 指针。
> 可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上。

**参考：**[http://git-scm.com](http://git-scm.com)
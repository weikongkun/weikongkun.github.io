---
title: 锁池与等待池
date: 2018-07-25 00:14:35
tags: 面试
categories: 面试
---

# Java中对锁池与等待池的理解？

对于 Java 虚拟机中运行程序的每个对象来说都有两个池，锁(monitor)池和等待(wait)池，而这两个池又与 Object 基类的 wait、notify、notifyAll 三个方法和 synchronized 相关（也可是 Lock 及 await 等）。

**锁池**的本质就是假设线程 A 已经拥有了某个对象（不是类）的锁，而其它线程 B、C 想要调用这个对象的某个 synchronized 方法（或者块），由于这些 B、C 线程在进入对象的 synchronized 方法（或者块）之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程 A 所拥有，所以这些 B、C 线程就进入了该对象的锁池，这就是锁池。

**等待池**的本质就是假设线程 A 调用了某个对象的 wait() 方法，线程 A 就会释放该对象的锁（因为 wait() 方法必须在 synchronized中使用，所以执行 wait() 方法前线程 A 已经持有了该对象的锁)，同时线程 A 就进入到了该对象的等待池中。如果此时线程 B 调用了相同对象的 notifyAll() 方法，则处于该对象等待池中的线程就会全部进入该对象的锁池中去准备争夺锁的拥有权。而如果此时线程 B 调用的是相同对象的 notify() 方法，则仅仅会有一个处于该对象等待池中的线程（随机）进入该对象的锁池中去准备争夺锁的拥有权。

**所以说锁池和等待池都是针对对象而言的**

# notify与notifyAll到底有什么区别？

简单说就是当一个线程调用了某个对象的 wait() 方法后就必须等其他线程调用这个对象的 notify/notifyall 方法；使用 notifyall 方法可以唤醒所有处于等待状态的线程，然后使其重新进入锁的争夺队列中，而使用 notify 方法只能唤醒处于等待状态的线程之一；此外如果使用 notify 不当很容易会导致并发死锁出现。

而从深层次来说就如上题答案所示，notifyAll 会让对象所有处于等待池的线程全部进入锁池去准备竞争获取一个锁的机会，没有获取到锁而已经呆在锁池的线程只能继续等待其他机会获取锁，而不能再主动回到等待池。对于 notify 来说只会让对象所有等待池中一个随机的线程进入锁池去竞争获取一个锁的机会。